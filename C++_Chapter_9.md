	接下来的一个系列都是进行C++的知识点积累，其实之前就已经看过两次这本书了，但是练习题没做，编程看了大概思路就自以为懂了，没有项目接触没有实际题目去思考去解决，也就导致了现在出现了三个方面的问题。
	1. 对于框架的认识停留在表面，也就是处于能够看懂基本流程，却在面临相同或者类似问题的时候却没法解决。
	2. 很多时候在编程过程中出现很多小问题，语法也好，不会debug也好，都是同样的问题，练得太少。
	3. 对于编程问题没有编程思想，对于问题的解决和想法依旧处于学生阶段，对问题的思考角度处于解决就行，不会深入去思考。

以上部分纯属个人声明发表，无所谓好坏，也无所谓对错。愿自己能够好好对待自己的生活。

Chapter 9 内存模型与命名空间
1. 头文件：包含结构声明和使用这些结构的函数原型
2. register 寄存器变量声明关键字	旨在提高访问变量的速度
3. 常量表达式初始化时一种动态初始化，在编译后即初始化
4. 外部变量可直接在函数中定义，但其他文件要使用，均必须声明，定义与声明均要用extern关键字
5. 
file 2: 
　　static int errors = 5;
　　void froobish()　｛｝
file 1:
　　int errors = 20;	//errors外部变量
file1与file2位于同个项目文件中，关键字static指出标识符errors的链接性为内部[只在程序运行时初始化一次，重复调用会在原来的基础上修改(上一次调用)]
6. 动态内存由运算符new和delete来控制，而不是由作用域和链接性规则控制，一般而言，C++存在自动释放(delete)的机制，但是作为一个良好的编程习惯，保证永远好过可能
7. sizeof关键字，不是函数：返回一个对象或者类型的长度
①定义在stddef.h，一般定义为typedef unsigned int size_t，类型为size_t，单位是字节
②当数组作为函数形参时退化为指针类型，	sizeof(*) = 8(在32位系统中)， 16(在64位系统中)
③结构体字长计算两原则：
	a. 整体空间必须是体内最大数据类型成员的整数倍
	b. 内存按数据成员的先后排列，当遇到最大成员时，已摆放和未摆放的空间大小都必须是该成员的整数倍
关于所占空间大小的几个小知识点：
	1. 空类大小为1,，空类的继承和多重继承大小也为1，虽然空类中并没有任何占内存大小的类型，但是作为一个类，在定义的同时又必须占有内存，否则就无法使用这些实例，因此sizeof的结果是1
	2. 对于含有虚函数的类sizeof的结果为8，类中有一个虚函数的映射表，存在指向虚函数的指针，一个映射表中有多个虚函数。
	3. static函数不占大小，static数据成员不归class，此是放在静态区中，是一个共享的作用域
	4. 位域与位段用得比较少，等用到时再仔细分析一波吧。

8. new作为定位运算符时，最好结合具体例子来谈。每次开辟空间时，都会从指定的内存空间进行开辟，从首地址默认开始
9. 有效地组织策略：①使用头文件来定义用户类型/类，数据类型和函数原型；②函数定义放在File2中；③业务逻辑实现放在File3中
10. 类实例化为对象时，对象的成员占据不同的内存为止，但成员函数却只占一个 。

